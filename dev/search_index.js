var documenterSearchIndex = {"docs":
[{"location":"#HEPExampleProject","page":"Home","title":"HEPExampleProject","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for HEPExampleProject.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#HEPExampleProject.ALPHA","page":"Home","title":"HEPExampleProject.ALPHA","text":"ALPHA \n\nThe fine-structure constant at tree level, given as 0.0072973525643(11).\n\nThis value is taken from the PDG 2020 recommended values of the fundamental physical constants.\n\nReferences\n\nThe Review of Particle Physics: P.A. Zyla et al. (Particle Data Group), Prog. Theor. Exp. Phys. 2020, 083C01 (2020)\n\n\n\n\n\n","category":"constant"},{"location":"#HEPExampleProject.ELECTRON_MASS","page":"Home","title":"HEPExampleProject.ELECTRON_MASS","text":"ELECTRON_MASS\n\nThe mass of the electron in its rest frame, given as 0.51099895000 MeV\n\nThis value is taken from the PDG 2020 recommended values of the fundamental physical constants.\n\nReferences\n\nThe Review of Particle Physics: P.A. Zyla et al. (Particle Data Group), Prog. Theor. Exp. Phys. 2020, 083C01 (2020)\n\n\n\n\n\n","category":"constant"},{"location":"#HEPExampleProject.MUON_MASS","page":"Home","title":"HEPExampleProject.MUON_MASS","text":"MUON_MASS \n\nThe mass of the muon in its rest frame, given as 105.6583755 MeV\n\nThis value is taken from the PDG 2020 recommended values of the fundamental physical constants.\n\nReferences\n\nThe Review of Particle Physics: P.A. Zyla et al. (Particle Data Group), Prog. Theor. Exp. Phys. 2020, 083C01 (2020)\n\n\n\n\n\n","category":"constant"},{"location":"#HEPExampleProject.Event","page":"Home","title":"HEPExampleProject.Event","text":"Event(\n    electron_momentum,\n    positron_momentum,\n    muon_momentum,\n    anti_muon_momentum,\n    weight\n)\n\nRepresents a single event in the process e^+ e^- to mu^+ mu^-, containing the four-momenta  of the electron, and positron in the initial state and muon, and anti-muon in the final state, along  with the corresponding event weight.\n\nFields\n\nelectron_momentum::FourMomentum: The four-momentum of the incoming electron.\npositron_momentum::FourMomentum: The four-momentum of the incoming positron.\nmuon_momentum::FourMomentum: The four-momentum of the outgoing muon.\nanti_muon_momentum::FourMomentum: The four-momentum of the outgoing anti-muon.\nweight::T: The weight of the event, representing the likelihood of the event occurring. Must be non-negative.\n\nExample\n\njulia> p_electron = FourMomentum(10.0, 0.0, 0.0, 9.0)\nFourMomentum(en = 10.0, x = 0.0, y = 0.0, z = 9.0)\n\n\njulia> p_positron = FourMomentum(10.0, 0.0, 0.0, -9.0)\nFourMomentum(en = 10.0, x = 0.0, y = 0.0, z = -9.0)\n\n\njulia> p_muon = FourMomentum(9.5, 2.0, 1.0, 8.0)\nFourMomentum(en = 9.5, x = 2.0, y = 1.0, z = 8.0)\n\n\njulia> p_anti_muon = FourMomentum(10.5, -2.0, -1.0, -8.0)\nFourMomentum(en = 10.5, x = -2.0, y = -1.0, z = -8.0)\n\n\njulia> weight = 1.2\n1.2\n\njulia> event = Event(p_electron, p_positron, p_muon, p_anti_muon, weight)\nEvent e-e+ -> mu-mu+\n\telectron:  (10.0, 0.0, 0.0, 9.0)\n\n\tpositron:  (10.0, 0.0, 0.0, -9.0)\n\n\tmuon:      (9.5, 2.0, 1.0, 8.0)\n\n\tanti muon: (10.5, -2.0, -1.0, -8.0)\n\n\tweight:    1.2\n\n\n\n\n\n","category":"type"},{"location":"#HEPExampleProject.FourMomentum","page":"Home","title":"HEPExampleProject.FourMomentum","text":"FourMomentum{T<:Real}(en::T, x::T, y::T, z::T)\n\nDefines a four-momentum vector energy and cartesian spatial components, where the type T  is a subtype of Real, allowing for arbitrary precision and numeric types.\n\nFields\n\nen: Energy component.\nx: Spatial component in the x-direction.\ny: Spatial component in the y-direction.\nz: Spatial component in the z-direction.\n\nExample\n\njulia> FourMomentum(4.0, 1.0, 2.0, 3.0)\nFourMomentum(en = 4.0, x = 1.0, y = 2.0, z = 3.0)\n\njulia> FourMomentum(4, 1.0, 2, 3) # implicit type promotion\nFourMomentum(en = 4.0, x = 1.0, y = 2.0, z = 3.0)\n\n\n\n\n\n","category":"type"},{"location":"#Base.:*-Tuple{Real, FourMomentum}","page":"Home","title":"Base.:*","text":"Base.:*(a::Real,p2::FourMomentum)\n\nDefines scalar multiplication for a FourMomentum object, scaling each component of the  four-momentum by a scalar a.\n\nExample\n\njulia> p = FourMomentum(4.0, 1.0, 2.0, 3.0)\nFourMomentum(en = 4.0, x = 1.0, y = 2.0, z = 3.0)\n\njulia> 2 * p\nFourMomentum(en = 8.0, x = 2.0, y = 4.0, z = 6.0)\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{FourMomentum, FourMomentum}","page":"Home","title":"Base.:+","text":"Base.:+(p1::FourMomentum,p2::FourMomentum)\n\nDefines vector addition for two FourMomentum objects. The result is a new FourMomentum  with each component being the sum of the corresponding components of p1 and p2.\n\nExample\n\njulia> p1 = FourMomentum(4.0, 1.0, 2.0, 3.0)\nFourMomentum(en = 4.0, x = 1.0, y = 2.0, z = 3.0)\n\n\njulia> p2 = FourMomentum(2.0, 0.5, 1.0, 1.5)\nFourMomentum(en = 2.0, x = 0.5, y = 1.0, z = 1.5)\n\n\njulia> p1 + p2\nFourMomentum(en = 6.0, x = 1.5, y = 3.0, z = 4.5)\n\n\n\n\n\n","category":"method"},{"location":"#Base.:--Tuple{FourMomentum, FourMomentum}","page":"Home","title":"Base.:-","text":"Base.:-(p1::FourMomentum,p2::FourMomentum)\n\nDefines vector subtraction for two FourMomentum objects. The result is a new FourMomentum  with each component being the difference between the corresponding components of p1 and p2.\n\nExample\n\njulia> p1 = FourMomentum(4.0, 1.0, 2.0, 3.0)\nFourMomentum(en = 4.0, x = 1.0, y = 2.0, z = 3.0)\n\njulia> p2 = FourMomentum(2.0, 0.5, 1.0, 1.5)\nFourMomentum(en = 2.0, x = 0.5, y = 1.0, z = 1.5)\n\njulia> p1 - p2\nFourMomentum(en = 2.0, x = 0.5, y = 1.0, z = 1.5)\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.build_unweighting_mask-Union{Tuple{T}, Tuple{T, Any}} where T","page":"Home","title":"HEPExampleProject.build_unweighting_mask","text":"build_unweighting_mask(E_in::T, event) where T\n\nBuild a mask to unweight events using the rejection sampling method. The mask filters events based on their weights, comparing each event's weight against a random value scaled by the maximum weight for the given  incoming energy E_in.\n\nArguments\n\nE_in::T: Incoming energy of the event (must be a subtype of Real).\nevent: The Event object whose weight will be compared.\n\nReturns\n\nA Boolean value indicating whether the event passes the unweighting criterion (true if accepted, false otherwise).\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.coords_to_dict-Tuple{Any, Any, Any}","page":"Home","title":"HEPExampleProject.coords_to_dict","text":"coords_to_dict(E_in::Real, cos_theta::Real, phi::Real)\n\nConstructs the four-momenta for an electron-positron annihilation process e^+ e^- rightarrow mu^+ mu^- in the center-of-mass frame. The input energy (E_in), scattering angle (cos_theta), and azimuthal angle (phi)  are used to compute the incoming and outgoing momenta for the particles.\n\nReturns\n\nA Dict mapping the particle names (\"e-\", \"e+\", \"mu-\", \"mu+\") to their respective FourMomentum objects.\n\nExample\n\njulia> mom_dict = coords_to_dict(1e3,0.9,pi/4)\nDict{String, FourMomentum{Float64}} with 4 entries:\n  \"mu+\" => (1000.0, -306.495431, -306.495431, -894.962239)…\n  \"mu-\" => (1000.0, 306.495431, 306.495431, 894.962239)…\n  \"e+\"  => (1000.0, 0.0, 0.0, -999.999869)…\n  \"e-\"  => (1000.0, 0.0, 0.0, 999.999869)…\n\njulia> mom_dict[\"e-\"]\nFourMomentum(en = 1000.0, x = 0.0, y = 0.0, z = 999.999869440028)\n\n\njulia> mom_dict[\"e+\"]\nFourMomentum(en = 1000.0, x = 0.0, y = 0.0, z = -999.999869440028)\n\n\njulia> mom_dict[\"mu-\"]\nFourMomentum(en = 1000.0, x = 306.4954310103767, y = 306.49543101037665, z = 894.9622389946002)\n\n\njulia> mom_dict[\"mu+\"]\nFourMomentum(en = 1000.0, x = -306.4954310103767, y = -306.49543101037665, z = -894.9622389946002)\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.differential_cross_section-Tuple{Any, Any}","page":"Home","title":"HEPExampleProject.differential_cross_section","text":"differential_cross_section(E_in::Real, cos_theta::Real)\n\nCalculates the differential cross section for the process e^+ e^- to mu^+ mu^-  at tree level in quantum electrodynamics (QED). The calculation is performed in the center-of-momentum  frame (CMS) as a function of the energy (E_in) of the incoming electron and the cosine of the  scattering angle (cos_theta), i.e. the angle between the incoming electron and outgoing muon.\n\nArguments\n\nE_in::Real: The energy of the electron/positron in MeV. In the center-of-momentum frame, this energy is equal to the energies of all incoming and outgoing particles.\ncos_theta::Real: The cosine of the scattering angle between the incoming electron and the outgoing muon.\n\nMethodology\n\nThis function computes the differential cross section using the following formula (from Schwartz 2014):\n\nfracmathrmdsigmamathrmdOmega = fracalpha^216 E_mathrmin^6left( E_textin^4 + rho_e^2 rho_mu^2 cos^2theta + E_textin^2 left( m_e^2 + m_mu^2 right) right)\n\nwhere:\n\nE_textin is the energy of the incoming electron/positron in CMS,\nrho_i = sqrtE_textin^2 - m_i^2 are the magnitude of three-momenta of the electron (i=e) and muon (i=mu) in the center-of-mass frame,\nalpha is the fine-structure constant,\nm_e and m_mu are the masses of the electron and muon, respectively.\n\nExample\n\njulia> E_in = 1e3 # MeV\n1000.0\n\njulia> cos_theta = 0.5\n0.5\n\njulia> differential_cross_section(E_in, cos_theta)\n4.164686491998452e-12\n\nReferences\n\nSchwartz 2014: M.D. Schwartz, \"Quantum Field Theory and the Standard Model\", Cambridge University Press, New York (2014)\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.filter_accepted-Tuple{Any}","page":"Home","title":"HEPExampleProject.filter_accepted","text":"filter_accepted(record_list)\n\nFilter out and return only the accepted events from a list of event records. Each record contains an event  and a Boolean mask indicating whether the event was accepted.\n\nArguments\n\nrecord_list: A list of tuples where each tuple contains an Event and a corresponding Boolean mask.\n\nReturns\n\nA list of accepted Event objects.\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.generate_event_and_masks-Tuple{Any}","page":"Home","title":"HEPExampleProject.generate_event_and_masks","text":"generate_event_and_masks(E_in)\n\nGenerate an event along with its unweighting mask. The mask is built based on the event's weight compared to  a randomly scaled maximum weight (see build_unweighting_mask for details).\n\nArguments\n\nE_in: Energy of the incoming electron (can be any Real type).\n\nReturns\n\nA tuple containing:\nevent: The generated event.\nmask: A Boolean indicating whether the event is accepted or rejected based on its weight.\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.generate_events-Union{Tuple{ARRAY_TYPE}, Tuple{T}, Tuple{T, Any}} where {T<:Real, ARRAY_TYPE<:AbstractVector{T}}","page":"Home","title":"HEPExampleProject.generate_events","text":"generate_events(E_in::T, nevents; array_type::Type{ARRAY_TYPE}=Vector{T}, chunksize=100) \nwhere {T<:Real, ARRAY_TYPE<:AbstractVector{T}}\n\nGenerate a specified number of unweighted events using rejection sampling. Events are generated in chunks,  and only accepted events are retained.\n\nArguments\n\nE_in::T: Energy of the incoming electron (must be a subtype of Real).\nnevents: The number of unweighted events to generate.\narray_type::Type{ARRAY_TYPE}: Optional; the type of array to use for the internal event generation (default is Vector{T}).\nchunksize: Optional; the number of events to generate per chunk (default is 100).\n\nReturns\n\nA list of unweighted Event objects.\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.generate_events_cpu-Union{Tuple{T}, Tuple{Random.AbstractRNG, T, Int64}} where T<:Real","page":"Home","title":"HEPExampleProject.generate_events_cpu","text":"generate_events_cpu(rng::AbstractRNG, E_in::Real, nevents::Int)\n\nGenerates a list of unweighted events for the process e^+ e^- to mu^+ mu^- using  the acceptance-rejection method. The events are generated according to the  differential_cross_section.\n\nArguments\n\nrng::AbstractRNG: A random number generator instance, used for sampling random numbers.\nE_in::Real: The center-of-mass energy of the incoming particles. \nnevents::Int: The number of unweighted events to generate.\n\nReturns\n\nunweighted_events: A list of Event objects. \n\nMethodology\n\nThe function generates trial events by randomly sampling cos_theta and calculating the event weight from the differential cross section.\nEvents are accepted if the sampled weight passes an acceptance-rejection test, where the probability of acceptance is proportional to the event weight.\nThe azimuthal angle (phi) is randomly sampled for accepted events, and the corresponding four-momenta for the incoming electron and positron, as well as the outgoing muons are constructed.\nThis process repeats until the desired number of events (nevents) is generated.\n\nExample\n\njulia> rng = MersenneTwister(137)\njulia> unweighted_events = generate_events_cpu(rng, 1e3, 1000);\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.generate_flat_event-Tuple{T} where T<:Real","page":"Home","title":"HEPExampleProject.generate_flat_event","text":"generate_flat_event(E_in::T) where {T<:Real}\n\nGenerate a flat event with a given incoming energy E_in. The event is characterized by a randomly sampled cosine of the polar angle (cth), azimuthal angle (phi), and a weight. The weight is computed using the  differential cross-section for the process.\n\nArguments\n\nE_in::T: Incoming energy of the event (must be a subtype of Real).\n\nReturns\n\nAn Event object containing the generated event's properties.\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.generate_flat_events_cpu-Union{Tuple{T}, Tuple{Random.AbstractRNG, T, Int64}} where T<:Real","page":"Home","title":"HEPExampleProject.generate_flat_events_cpu","text":"generate_flat_events_cpu(rng::AbstractRNG, E_in::Real, nevents::Int)\n\nGenerates a list of weighted events for the process e^+ e^- to mu^+ mu^- using a  flat random distribution in the cosine of the scattering angle and azimuthal angle.\n\nArguments\n\nrng::AbstractRNG: A random number generator instance, used for sampling random numbers.\nE_in::Real: The energy of the incoming electron.\nnevents::Int: The number of events to generate.\n\nReturns\n\nevent_list: A list of Event objects, where each event contains:\n\nMethodology\n\nRandomly generates the cosine of the scattering angle (cos_theta) and azimuthal angle (phi) for each event.\nUses the differential_cross_section to compute the weights for each event.\nConstructs the four-momenta of the outgoing muons and anti-muons from the random angles and the input energy E_in.\nReturns a list of Event objects containing the momenta and corresponding event weights.\n\nExample\n\njulia> rng = MersenneTwister(137)\njulia> event_list = generate_flat_events_cpu(rng, 1e3, 1000);\n\nThe ; should be used at the end of the last promt to suppress printing the whole event list.\n\nNotes\n\nThis method generates weighted events where the weights are derived from the differential cross section. For unweighted events, use generate_events_cpu.\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.max_weight-Tuple{Any}","page":"Home","title":"HEPExampleProject.max_weight","text":"max_weight(E_in)\n\nReturn the maximum weight, i.e. the maxmaximum value of differential_cross_section for specified initial electron energy `E_in. \n\nExample\n\njulia> max_weight(1e3)\n6.619160791345756e-12\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.minkowski_dot-Tuple{FourMomentum, FourMomentum}","page":"Home","title":"HEPExampleProject.minkowski_dot","text":"minkowski_dot(p1::FourMomentum, p2::FourMomentum)\n\nComputes the Minkowski dot product of two four-momentum vectors. The dot product uses the  Minkowski metric (+,-,-,-). For p_i = (E_ip_i^xp_i^yp_i^z) with i=12, the result is:\n\n    p_1 cdot p_2 = E_1E_2 - p_1^xp_2^x - p_1^yp_2^y + p_1^zp_2^z\n\nExample\n\njulia> p1 = FourMomentum(4.0, 1.0, 2.0, 3.0)\nFourMomentum(en = 4.0, x = 1.0, y = 2.0, z = 3.0)\n\njulia> p2 = FourMomentum(3.0, 0.5, 1.0, 1.5)\nFourMomentum(en = 3.0, x = 0.5, y = 1.0, z = 1.5)\n\njulia> minkowski_dot(p1, p2)\n5.0\n\n\n\n\n\n","category":"method"},{"location":"#HEPExampleProject.total_cross_section-Tuple{Any}","page":"Home","title":"HEPExampleProject.total_cross_section","text":"total_cross_section(E_in::Real)\n\nCalculates the total cross section for the process e^+ e^- to mu^+ mu^- at tree level, as a function of the initial electron energy E_in.\n\nArguments\n\nE_in::Real: The energy of the initial electron/positron in MeV.\n\nMethodology\n\nThe calculation is based on the analytical integration of the differential_cross_section and uses the following formula for the total cross section:\n\nmathrmdsigma(E_in) = fracpi alpha^28 E_textin^6 cdot fracrho_murho_e left( 2 E_textin^4 + frac23 rho_mu^2 rho_e^2 + 2 E_textin^2 (m_mu^2 + m_e^2) right)\n\nwhere: \n\nE_textin is the energy of the incoming electron/positron in CMS,\nrho_i = sqrtE_textin^2 - m_i^2 are the magnitude of three-momenta of the electron (i=e) and muon (i=mu) in the center-of-mass frame,\nalpha is the fine-structure constant,\nm_e and m_mu are the masses of the electron and muon, respectively.\n\nExample\n\njulia> E_in = 1e3 # MeV\n1000.0\n\njulia> total_cross_section(E_in)\n5.576208658540326e-11\n\n\n\n\n\n\n","category":"method"}]
}
